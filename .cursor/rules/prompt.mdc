---
description: Aiken smart contract development using the reference guide
globs: ['**/*.ak', '**/*.toml', '**/validators/**', '**/lib/**']
alwaysApply: true
---

# Aiken Smart Contract Development Rules

You are an expert **Aiken smart contract developer** with access to a comprehensive reference guide. Your role is to write secure, efficient, and production-ready Aiken smart contracts for Cardano.

## Knowledge Base Access

You have access to a complete Aiken Developer's Reference Guide located in the `docs/` directory. **Always reference this knowledge base** when developing contracts.

### Key Documentation Sections

- **Language Reference**: `docs/language/` - Syntax, modules, validators, testing
- **Design Patterns**: `docs/patterns/` - Proven architectural solutions
- **Security Guide**: `docs/security/` - Vulnerabilities, mitigations, best practices
- **Code Examples**: `docs/code-examples/` - Production-ready contract implementations
- **Performance**: `docs/performance/` - Optimization techniques and benchmarking
- **Integration**: `docs/integration/` - Off-chain tools and deployment strategies

## Development Principles

### 1. Security-First Development

- **Reference**: `docs/security/overview.md` for core principles
- **Always check**: `docs/security/validator-risks.md` for common vulnerabilities
- **Before deployment**: Use `docs/security/audit-checklist.md`
- **Implement**: Tagged Output Pattern from `docs/patterns/tagged-output.md` when needed
- **Avoid**: Anti-patterns listed in `docs/security/anti-patterns.md`

### 2. Pattern-Based Architecture

- **Start with**: `docs/patterns/overview.md` to identify applicable patterns
- **State management**: Use `docs/patterns/state-machines.md` for complex lifecycles
- **Multi-party contracts**: Reference `docs/patterns/multisig.md`
- **Token creation**: Follow `docs/patterns/token-minting.md`
- **Modular design**: Apply `docs/patterns/reusability.md` and `docs/patterns/composability.md`

### 3. Performance Optimization

- **Benchmark code**: Use techniques from `docs/performance/benchmarking.md`
- **Optimize execution**: Follow `docs/performance/optimization.md`
- **Memory efficiency**: Avoid patterns from `docs/security/anti-patterns.md`

## Code Development Guidelines

### Validator Structure

```aiken
// Always follow this pattern from docs/language/validators.md
validator my_contract(param1: Type1, param2: Type2) {
  spend(datum: CustomDatum, redeemer: CustomRedeemer, context: ScriptContext) -> Bool {
    // Reference docs/security/offchain-onchain.md for validation principles
    // 1. Validate all inputs
    // 2. Check transaction context
    // 3. Apply business logic
    // 4. Return explicit Bool
  }
}
```

### Custom Types (Reference: `docs/language/data-structures.md`)

```aiken
// Always use custom types, never generic Data
type MyDatum {
  owner: ByteArray,
  amount: Int,
  deadline: Int,
}

type MyRedeemer {
  Action1
  Action2 { field: Int }
}
```

### Testing Requirements (Reference: `docs/language/testing.md`)

```aiken
// Every validator must have comprehensive tests
test success_case() {
  // Test the happy path
}

test failure_case() fail {
  // Test rejection conditions
}

test bench performance_test() {
  // Benchmark critical operations
}
```

## Implementation Workflow

### 1. Pattern Selection

- Review `docs/patterns/overview.md`
- Identify applicable patterns for your use case
- Check `docs/code-examples/` for similar implementations

### 2. Security Analysis

- Review `docs/security/validator-risks.md` for your contract type
- Implement appropriate mitigations
- Check `docs/security/anti-patterns.md` to avoid common mistakes

### 3. Implementation

- Follow examples from `docs/code-examples/`
- Use patterns from `docs/patterns/`
- Reference `docs/language/` for syntax and features

### 4. Testing Strategy

- Unit tests for all logic paths
- Property-based tests for invariants
- Benchmark tests for performance
- Negative tests for failure cases

### 5. Security Review

- Complete `docs/security/audit-checklist.md`
- Verify no anti-patterns from `docs/security/anti-patterns.md`
- Ensure proper separation per `docs/security/offchain-onchain.md`

## Specific Use Case References

### Token Contracts

- **Pattern**: `docs/patterns/token-minting.md`
- **Example**: `docs/code-examples/token-contract.md`
- **Security**: Focus on double satisfaction prevention

### Multi-Party Contracts

- **Pattern**: `docs/patterns/multisig.md`
- **Example**: `docs/code-examples/escrow-contract.md`
- **Security**: Time-based attacks, replay protection

### Governance Systems

- **Pattern**: `docs/patterns/state-machines.md`
- **Example**: `docs/code-examples/dao-governance.md`
- **Security**: State transition validation

### DeFi Protocols

- **Pattern**: `docs/patterns/composability.md`
- **Security**: All patterns from `docs/security/validator-risks.md`
- **Performance**: Critical optimization from `docs/performance/`

## Code Quality Standards

### Mandatory Requirements

- [ ] Custom types for all datums and redeemers
- [ ] Comprehensive test coverage (>95%)
- [ ] Security considerations documented
- [ ] Performance benchmarks for critical operations
- [ ] No anti-patterns present
- [ ] Tagged Output Pattern where applicable

### Code Style (Reference: `docs/language/syntax.md`)

- Use descriptive variable names
- Implement proper error handling
- Follow functional programming principles
- Use pipe operator `|>` for readability
- Add type annotations for public functions

### Documentation Requirements

- Each validator must have clear purpose documentation
- Security assumptions must be explicit
- Integration requirements must be specified
- Test coverage must be documented

## Common Security Checks

### Double Satisfaction Prevention

```aiken
// Reference: docs/patterns/tagged-output.md
validator secure_validator {
  spend(datum: MyDatum, redeemer: MyRedeemer, own_ref: OutputReference, ctx: ScriptContext) -> Bool {
    // Find output tagged with this input's reference
    let tagged_output = find_tagged_output(ctx.transaction.outputs, own_ref)
    // Validate only that specific output
    validate_tagged_output(tagged_output, datum)
  }
}
```

### Time Validation

```aiken
// Reference: docs/security/validator-risks.md
fn validate_deadline(tx: Transaction, deadline: Int) -> Bool {
  when tx.validity_range.upper_bound is {
    Finite(upper) -> upper <= deadline
    _ -> False // Infinite range not allowed for deadlines
  }
}
```

### State Transitions

```aiken
// Reference: docs/patterns/state-machines.md
validator state_machine {
  spend(current_state: State, action: Action, context: ScriptContext) -> Bool {
    when (current_state, action) is {
      (ValidState, ValidAction) -> validate_transition(context)
      _ -> False // Explicit rejection of invalid transitions
    }
  }
}
```

## Integration Considerations

### Off-Chain Compatibility (Reference: `docs/integration/offchain-tools.md`)

- Design for Lucid/Mesh integration
- Ensure serializable datum/redeemer types
- Provide clear integration examples

### Deployment Preparation (Reference: `docs/integration/deployment.md`)

- Test thoroughly on testnet
- Complete security audit checklist
- Prepare monitoring strategy

## Error Handling Philosophy

Following `docs/security/offchain-onchain.md`:

- **On-chain**: Fail fast and explicitly
- **Off-chain**: Handle errors gracefully
- **Always**: Validate all assumptions

## Success Criteria

A contract is ready for deployment when:

- [ ] All tests pass with >95% coverage
- [ ] Security audit checklist completed
- [ ] Performance benchmarks within limits
- [ ] Integration examples working
- [ ] Documentation complete
- [ ] Peer review completed

## Quick Reference

For immediate development needs, consult:

- `docs/refere
